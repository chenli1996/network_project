param N > 0 integer;
param E > 0 integer;
param U > 0 integer;
param S > 0 integer;
set Nodes   := 1..N;
set Service :=1..S;
set Links   := 1..E;
set Users := 1..U;


## link generation
param link_src {Links} within Nodes;
param link_dst {Links} within Nodes;
param c {Links} > 0;
param xi{Links} > 0 ;# unit cost on link e

##service parameters
param l{Links} > 0;#link delay
param w{Service} > 0;#service profits
param s{Users} > 0 integer; #service of user
param h{Service} > 0; #bandwidth for service
param m{Service} > 0;#service memory
param comp{Service} >= 0;#service computational
param L{Users} > 0;

param Comp_N{Nodes} >= 0;#node computational
param M{Nodes} >= 0;#node memory
param K{Nodes} >= 0;#node serving limitation
param t{Service} > 0;#service delay tolerance
#set N1      := {1, 2, 3};
param Nu{Nodes,Users} >= 0 ;

#set N2      := {1,3};
#set N3      := {1,2};
#set N4      := {2,3};
#set N5      := {2};
#set N6      := {3};
#set N7      := {1};
#param Nu{Users}  := 
#	1	{1, 2, 3}
#	2	{1, 3}
#	3	{1, 2}
#	4	{2, 3}
#	5	{2}
#	6	{3}
#	7	{1};
#{{1, 2, 3},{1,3},{1,2},{2,3},{2},{3},{1}};

## demand generation
#param demand_src {Demands} within Nodes;
#param demand_dst {Demands} within Nodes;
#param h {v1 in Nodes, v2 in Nodes} >= 0;
#param H {v in Nodes} := sum {n in Nodes diff {v}} h[v,n];


## defining start and end nodes of the links
param a {e in Links, n in Nodes} 
	 := if link_src[e]=n then 1 else 0;
	 
param b {e in Links, n in Nodes} 
	 := if link_dst[e]=n then 1 else 0;	 
	 
# Variables
var x {Nodes,Users} binary; # 1 if the request of user u is served st not n, 0 otherwise sum{n in Nodes} x[n,u]
#var s{Service,Users} binary; # 1 if the user u choose service s

#var Nu{N1,1} binary;
var z {Nodes,Users} binary;#1 if user conncet to the network through node n, 0 otherwise and we use z[n,u]*Nu[n,u] to indecate the conncetable subset node for each user
#var z {N3,3} binary;
#var z {N4,4} binary;
#var z {N5,5} binary;
#var z {N6,6} binary;
#var z {N7,7} binary;
var ue{Users,Links} binary; # 1 if the link e is used while serving the user u, 0 otherswise
var y{Links} >= 0 ; #traffic on link e
var indecator{n in Nodes, u in Users} = z[n,u]*Nu[n,u]-x[n,u];
var one_path_left{n in Nodes, u in Users} = sum{e in Links}a[e,n]*ue[u,e]-sum{e in Links}b[e,n]*ue[u,e];
#var r {Links} >= 0; # link delay
	 
## objective function	 
maximize revenue: sum{u in Users} w[s[u]]*(sum{n in Nodes} x[n,u]) - sum{u in Users}(sum{e in Links} ue[u,e]*xi[e]*y[e]);
#maximize revenue: sum{u in Users} sum{n in Nodes} x[u,n];

## a user can be served at most one location or leglected
subj to served_constraint {u in Users}: 
sum{n in Nodes} x[n,u] <= 1;

## access one node if a user is served, or users is dropped off
subj to access_constraint {u in Users}:  
#sum{n in Nu[Users]} z[n,u] = sum{n in Nodes} x[n,u] ;
sum{n in Nodes} z[n,u]*Nu[n,u] = sum{n  in Nodes} x [n,u];
#sum{n in N2} z[n,2] = sum{n in Nodes} x[n,2] ;
#sum{n in N3} z[n,3] = sum{n in Nodes} x[n,3] ;
#sum{n in N4} z[n,4] = sum{n in Nodes} x[n,4] ;
#sum{n in N5} z[n,5] = sum{n in Nodes} x[n,5] ;
#sum{n in N6} z[n,6] = sum{n in Nodes} x[n,6] ;
#sum{n in N7} z[n,7] = sum{n in Nodes} x[n,7] ;


## the flow generated by user u should be allocated to links if and only if that user is to be servd:
subj to allocated_constraint{u in Users}:
sum{ e in Links} ue[u,e] <= E*(sum{n in Nodes} x[n,u]);


## each link has a capacity bound
subj to link_capacity {e in Links}:
sum{u in Users} ue[u,e]*h[s[u]] <= c[e];

subj to link_load {e in Links}:
sum{u in Users} ue[u,e]*h[s[u]] = y[e];

## node memory bound
subj to node_memory {n in Nodes}:
sum{u in Users} x[n,u]*m[s[u]] <= M[n];

## node computational bound
subj to node_computation {n in Nodes}:
sum{u in Users} x[n,u]*comp[s[u]] <= Comp_N[n];

## node serving limitation
subj to node_serving {n in Nodes}:
sum{u in Users} z[n,u]*Nu[n,u] <= K[n];

## service delay tolerance, otherwise drop off
subj to sercive_delay {u in Users}:
sum{e in Links} ue[u,e]*l[e]<=t[s[u]];

## one service one path
subj to one_path {n in Nodes, u in Users}:
sum{e in Links}a[e,n]*ue[u,e]-sum{e in Links}b[e,n]*ue[u,e] = z[n,u]*Nu[n,u]-x[n,u];




